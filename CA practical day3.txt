
----------------------------------sum of 3 with Meemory address----------------------------------

.data
String1: .asciiz "Input a number: "
String2: .asciiz "Output = "
int1:    .word 0
int2:    .word 0
int3:    .word 0
ans:     .word 0

.text

main:
    la $a0, String1
    li $v0, 4
    syscall

    li $v0, 5
    syscall
    sw $v0, int1

    la $a0, String1
    li $v0, 4
    syscall

    li $v0, 5
    syscall
    sw $v0, int2

    la $a0, String1
    li $v0, 4
    syscall

    li $v0, 5
    syscall
    sw $v0, int3

    lw $t0, int1
    lw $t1, int2
    lw $t2, int3

    add $t3, $t0, $t1
    add $t3, $t3, $t2

    la $a0, String2
    li $v0, 4
    syscall

    li $v0, 1
    move $a0, $t3
    syscall

    li $v0, 10
    syscall


-----------------------------------print numbers till count using loop--------------------------

# Use .set noreorder to prevent the assembler from filling branch
# delay slots, if you want to fill delay slots manually.
# .set noreorder
.data
string1: .asciiz "Sequence:"
count: .word 20
.text
.global _start
_start:
	jal main
	li $v0, 10
	syscall		# Use syscall 10 to stop simulation
	
main:
	la $a0, string1 # load address of string to be printed into $a0
	li $v0, 4 # code for printing string is 4
	syscall # call operating system to perform print operation

	move $t0, $zero
	lw $t1, count # Load from memory

	loop:
	move $a0, $t0
	li $v0, 1 # code for printing integer is 1
	syscall
	addi $t0, 1
	ble $t0, $t1, loop

	li $v0, 10
	syscall # Use syscall 10 to stop simulation

--------------------------Program to print a sequence from 0 to n ----------------
.data
string1: .asciiz "Sequence: "
comma:   .asciiz ", "

.text
.globl main

main:
   
    # Read integer n
    li  $v0, 5          # read integer
    syscall
    move $t1, $v0       # t1 = n

	move $t0, $zero     # t0 = 0 (counter)

 	# Print "Sequence:"
    la  $a0, string1
    li  $v0, 4          # print string
    syscall

loop:
    # Print current number
    move $a0, $t0
    li   $v0, 1         # print integer
    syscall

    # If t0 == n, exit loop
    beq  $t0, $t1, end

    # Print ", "
    la   $a0, comma
    li   $v0, 4         # print string
    syscall

    addi $t0, $t0, 1    # t0++
    j    loop

end:
    li $v0, 10
    syscall             # exit


-------------------------------Read two integers n1, n2 and print all the numbers from n1 to n2--------------------------------------

# Use .set noreorder to prevent the assembler from filling branch
# delay slots, if you want to fill delay slots manually.
# .set noreorder
.data
string1: .asciiz "input 1: "
string2: .asciiz "input 2: "
string3: .asciiz "sequence: "
comma: .asciiz ", "
.text

.global _start
_start:
	jal main
	li $v0, 10
	syscall		# Use syscall 10 to stop simulation

main:
	la  $a0, string1
    li  $v0, 4          # print string
    syscall

	li $v0, 5
	syscall
	move $t1, $v0
	
	la  $a0, string2
    li  $v0, 4          # print string
    syscall
	
	li $v0, 5
	syscall
	move $t2, $v0
	
	la  $a0, string3
    li  $v0, 4          # print string
    syscall
	
loop:
	move $a0, $t1
	li $v0, 1
	syscall
	
	beq  $t2, $t1, end
	
	la $a0, comma
	li $v0, 4
	syscall
	
	addi $t1, $t1, 1    # t0++
    j    loop
	
end:
    li $v0, 10
    syscall     

-------------------------------------------Read three integers n1, n2, n3 and print all the numbers from n1 to n2 incremented by n3---------------------------------------------

# Use .set noreorder to prevent the assembler from filling branch
# delay slots, if you want to fill delay slots manually.
# .set noreorder
.data
inp1: .asciiz "input1: "
inp2: .asciiz "input2: "
inp3: .asciiz "input3: "
space: .asciiz " "
output:  .asciiz "Output: "

.text

.global _start
_start:
	jal main
	li $v0, 10
	syscall		# Use syscall 10 to stop simulation

main:
	# read num1
	la $a0, inp1
	li $v0, 4
	syscall
	
	li $v0, 5
	syscall
	move $t0, $v0
	
	# read num2
	la $a0, inp2
	li $v0, 4
	syscall
	
	li $v0, 5
	syscall
	move $t1, $v0
	
	# read num3
	la $a0, inp3
	li $v0, 4
	syscall
	
	li $v0, 5
	syscall
	move $t2, $v0
	
	# --- Print output label ---
    li $v0, 4
    la $a0, output
    syscall
	
	move $t3, $t0      # t3 = current number (start from n1)
	
	loop:
    ble $t1, $t3, end  # if current > n2, end loop
    li $v0, 1          # print integer
    move $a0, $t3
    syscall

    add $t3, $t3, $t2  

	la $a0, space
	li $v0, 4
	syscall

    ble $t3, $t1, loop 
    

end:
    li $v0, 10    
    syscall
